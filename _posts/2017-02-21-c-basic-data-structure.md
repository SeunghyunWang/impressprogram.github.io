---
layout: post
comments: true
title: 자료구조의 소개, 복잡도(C언어)
categories: [datastructure]
tags: [c, datastructure]
fullview: true
---

# 자료구조란?

자료구조는 데이터를 표현하고 저장하는 방법에 대해서 설명합니다.  
넓은 의미에서 int형 변수, 구조체의 정의, 배열도 자료구조의 일종인 것입니다.  
자료구조를 기본적으로 분류하자면 아래와 같습니다.  

- 선형구조 => 리스트, 스택, 큐
- 비선형구조 => 트리, 그래프
- 파일구조 => 순차파일, 색인파일, 직접파일
- 단순구조 => 정수, 실수, 문자, 문자열

참고로 선형이란 데이터를 선의 형태로 나란히 혹은 일렬로 저장하는 방식입니다.  
비선형 자료구조는 데이터를 나란히 저장하지 않는 구조입니다.  
자료구조와 알고리즘의 차이에 대해서도 언급을 하자면 자료구조가 우선 이루어져야 알고리즘을 적용시킬 수 있습니다.  
즉, 알고리즘은 자료구조에 의존적입니다.  
따라서 보통 자료구조 서적들이 자료구조를 설명하고 그와 관련이 있는 알고리즘을 더불어 설명하는 것입니다.

# 시간 복잡도와 공간 복잡도

시간 복잡도는 실행 속도에 대한 이슈를 다루고 공간 복잡도는 메모리의 사용량에 대한 이슈를 다룹니다.  
그러나 대게는 메모리가 요새 충분하기 때문에 공간 복잡도는 생각을 많이 안하고 시간 복잡도만 고려하는 경우가 많습니다.  
시간 복잡도는 보통 연산의 횟수를 세서 계산합니다.  
데이터의 수에 따른 연산횟수의 증가량을 파악해서 알고리즘의 성능을 판단하는 것입니다.  
쉽게 생각하면 다중 for문이 많을수록 데이터 수에 따라 연산이 급격하게 증가하므로 수행 시간도 길게 나타나는 것을 떠올리면 될 것 같습니다.  

# 시간복잡도

순차 탐색 알고리즘으로 간단하게 시간복잡도에 대한 이야기를 더 해보겠습니다.

```
int sequentialSearch(int array[], int n, int value) { // Starts from n to m
    int i;
    for (i = 0; i < n; i++)
        if (array[i] == value)
            return i;
    return -1;
}
```

원하는 값을 n에서 m사이에 있는지 찾아주고 위치를 반환해주는 함수입니다.  
연산이 적게 일어나려면 if(array[i]==value) 부분이 최대한 적게 일어나야 함을 알 수 있습니다.  
그런데 운이 좋아서 한번에 찾을 경우에는 연산 수행 횟수가 1이 되고 운이 나빠서 n까지 모두 돌고서야 value값을 찾는다면 연산 수행 횟수가 n이 될 것입니다.  
이를 '최선의 경우'와 '최악의 경우'라고 표현합니다.  
알고리즘을 평가하는데는 보통 '최악의 경우'를 기준으로 평가합니다.  

다음으로는 탐색 알고리즘 중에서 이것보다 좀 더 빠른 알고리즘인 이진탐색을 살펴보겠습니다.  
단 이 알고리즘은 쓰려면 자료가 크기 순서대로 정렬되어있어야합니다.  
아래는 나무위키에 나와있는 글로 이진탐색을 이해하기 좋은 것 같아서 가져왔습니다.

```
function 이진탐색(데이터, 찾는 값)

데이터가 혹시 비어 있는가?
(네) return 찾는 값 없음.

데이터의 가운데 지점을 찾는다.
찾은 지점의 데이터를 뽑는다.
뽑은 데이터가 찾는 값인가?

(네) return 뽑은 데이터.
(아니오)
  뽑은 데이터와 찾는 값을 비교한다.
  (뽑은 데이터가 찾는 값보다 큰 값인가?)
    return 이진탐색(데이터 앞쪽 절반, 찾는 값)
  (작은 값인가?)
    return 이진탐색(데이터 뒤쪽 절반, 찾는 값)
```

한번 탐색을 할 때마다 탐색 범위를 절반씩 날려버려서 한 눈에 봐도 연산횟수가 많음을 알 수 있습니다.  
C언어 함수코드입니다.  

```
￼int bSearch(T arr[], T val, int first, int last)
{
    if (first >= last) return -1;

    int mid = (first + last) / 2;
    if (val == arr[mid])
        return mid;
    else if (val < arr[mid])
        return bSearch(arr, val, first, mid – 1);
    else
        return bSearch(arr, val, mid + 1, last);
}
```

위의 코드가 이해가 가지 않는다면 다음 포스팅인 '재귀함수'를 읽어보시는 것을 추천드립니다.  
위에 순차 탐색 알고리즘은 최악의 경우에 n만큼 걸렸습니다.  
즉 8개의 데이터가 있다면 8만큼의 연산이 이루어졌을 것입니다.  
하지만 이진탐색은 8 -> 4 -> 2 -> 1 이렇게 데이터의 범위를 좁혀가기 때문에 최악의 경우에도 4번의 연산만이 이루어집니다.  
단, 데이터가 크기 순서대로 정렬되어 있어야 함은 명심하셔야합니다.  

# 빅 - 오 표기법

나무위키에서 설명을 잘 해놓았습니다.  
https://namu.wiki/w/%EC%A0%90%EA%B7%BC%20%ED%91%9C%EA%B8%B0%EB%B2%95  
앞서 말씀드린 알고리즘 시간 복잡도 함수를 대략적으로 구하는 방법입니다.  
알기 쉽게 근사치로 가장 높은 차수만을 고려하는 표기법입니다.  
